<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第一周算法日记 | XY·夜星</title><meta name="author" content="夜星"><meta name="copyright" content="夜星"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这周算法主要练习了数组，链表以及哈希表，周赛中考的深度优先搜索和广度优先搜索都不太会，只写出来一道，感觉自己有点太菜了，之后要多练习一下 数组二分查找二分法，是定义一个中间值变量，比对两端点的值，然后更换搜索区间 &#x2F;**  * @param &amp;#123;number[]&amp;#125; nums  * @param &amp;#123;number&amp;#125; target  * @return &amp;#123;">
<meta property="og:type" content="website">
<meta property="og:title" content="第一周算法日记">
<meta property="og:url" content="http://example.com/algorithm/first.html">
<meta property="og:site_name" content="XY·夜星">
<meta property="og:description" content="这周算法主要练习了数组，链表以及哈希表，周赛中考的深度优先搜索和广度优先搜索都不太会，只写出来一道，感觉自己有点太菜了，之后要多练习一下 数组二分查找二分法，是定义一个中间值变量，比对两端点的值，然后更换搜索区间 &#x2F;**  * @param &amp;#123;number[]&amp;#125; nums  * @param &amp;#123;number&amp;#125; target  * @return &amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-09-09T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-10T03:22:31.395Z">
<meta property="article:author" content="夜星">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/icon_favicon.jpeg"><link rel="canonical" href="http://example.com/algorithm/first.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第一周算法日记',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-09-10 11:22:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avator.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/technologyStudy/"><i class="fa-fw fas fa-tags"></i><span> 技术学习</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fa-folder-open"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/webFontBasic/"><i class="fa-fw fas fa-archive"></i><span> 前端基础</span></a></div><div class="menus_item"><a class="site-page" href="/apiInMy/"><i class="fa-fw fas fa-heart"></i><span> 手写API</span></a></div><div class="menus_item"><a class="site-page" href="/webServer/"><span> 后端</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/algorithm/"><span> 算法</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fas fa-heart"></i><span> 杂记</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header" style="background-image: url('/img/top_bac.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="XY·夜星"><span class="site-name">XY·夜星</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/technologyStudy/"><i class="fa-fw fas fa-tags"></i><span> 技术学习</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fa-folder-open"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/webFontBasic/"><i class="fa-fw fas fa-archive"></i><span> 前端基础</span></a></div><div class="menus_item"><a class="site-page" href="/apiInMy/"><i class="fa-fw fas fa-heart"></i><span> 手写API</span></a></div><div class="menus_item"><a class="site-page" href="/webServer/"><span> 后端</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/algorithm/"><span> 算法</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fas fa-heart"></i><span> 杂记</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="page-site-info"><h1 id="site-title">第一周算法日记</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><p>这周算法主要练习了数组，链表以及哈希表，周赛中考的深度优先搜索和广度优先搜索都不太会，只写出来一道，感觉自己有点太菜了，之后要多练习一下</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分法，是定义一个中间值变量，比对两端点的值，然后更换搜索区间</p>
<pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number&#125;
 */
var search = function (nums, target) &#123;
  let left = 0;
  let right = nums.length - 1;
  // 搜索区间是左闭右闭，while循环值以及里边的判断值要判断区间的合法性
  while (left &lt;= right) &#123;
    const middle = (left + right) &gt;&gt; 1;
    if (nums[middle] &gt; target) &#123;
      // 中间值大于目标值，搜索区间中不用包含该值
      right = middle - 1;
    &#125; else if (nums[middle] &lt; target) &#123;
      // 中间值小于目标值，搜索区间也不用包含该值
      left = middle + 1;
    &#125; else &#123;
      // 相等，获得目标结果
      return middle;
    &#125;
  &#125;
  // 没有找到
  return -1;
&#125;;
</code></pre>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; val
 * @return &#123;number&#125;
 */

/*
如果匹配到后边的值会前移覆盖掉，i指针会指向下一个值，后续
如果有符合要求的话会继续覆盖值
*/
var removeElement = function (nums, val) &#123;
  // 记录有几个符合规则的数，后边值进行覆盖
  let i = 0;
  for (let j = 0; j &lt; nums.length; j++) &#123;
    // 符合规矩直接修改值
    if (nums[j] !== val) &#123;
      nums[i] = nums[j];
      i++;
    &#125;
  &#125;
  return i;
&#125;;
</code></pre>
<h3 id="长度最小的子数组（滑动窗口）"><a href="#长度最小的子数组（滑动窗口）" class="headerlink" title="长度最小的子数组（滑动窗口）"></a>长度最小的子数组（滑动窗口）</h3><pre><code class="javascript">/**
 * @param &#123;number&#125; target
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var minSubArrayLen = function (target, nums) &#123;
  let sum = 0;
  let left = 0;
  // 将结果值初始定为最大值(因为结果值最大值也不会超过num.length+1)
  let res = nums.length + 1;
  // 一重个for循环，循环里边使用while语句去找滑动窗口的值
  for (let i = 0; i &lt; nums.length; i++) &#123;
    sum += nums[i];
    // 如果大于目标值，移动左指针，并还原sum值(大于等于所以包含结果未1的情况)
    while (sum &gt;= target) &#123;
      sum -= nums[left];
      // 因为i从0开始所以加1
      res = Math.min(res, i - left + 1);
      left++;
    &#125;
  &#125;
  // res值是否未更新(未更新表示所有和都达不到)
  return res &gt; nums.length ? 0 : res
&#125;;
</code></pre>
<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p>左闭右开，不去处理最后一个节点</p>
<pre><code class="javascript">// 定义一个二维数组
let arr = Array(m).fill().map(() =&gt; Array(n));
</code></pre>
<pre><code class="javascript">/**
 * @param &#123;number&#125; n
 * @return &#123;number[][]&#125;
 */
var generateMatrix = function (n) &#123;
  // 定义四个边界值
  let l = 0, r = n - 1, t = 0, b = n - 1;
  let res = Array(n).fill().map(() =&gt; Array(n));
  let num = 1, tar = n * n;
  while (num &lt;= tar) &#123;
    for (let i = l; i &lt;= r; i++) res[t][i] = num++; // 从左到右
    t++;
    for (let i = t; i &lt;= b; i++) res[i][r] = num++; // 从上到下
    r--;
    for (let i = r; i &gt;= l; i--) res[b][i] = num++; // 从右到左
    b--;
    for (let i = b; i &gt;= t; i--) res[i][l] = num++; // 从下到上
    l++;
  &#125;
  return res;
&#125;;
</code></pre>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>虚拟头节点</p>
<h3 id="删除链表元素"><a href="#删除链表元素" class="headerlink" title="删除链表元素"></a>删除链表元素</h3><pre><code class="javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @param &#123;number&#125; val
 * @return &#123;ListNode&#125;
 */
var removeElements = function (head, val) &#123;
  const ret = new ListNode(0, head);
  let cur = ret;
  while (cur &amp;&amp; cur.next) &#123;
    if (cur.next.val === val) &#123;
      cur.next = cur.next.next;
      // 不等于的时候才指向下一个
    &#125; else &#123;
      cur = cur.next;
    &#125;
  &#125;
  return ret.next;
&#125;;
</code></pre>
<h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><pre><code class="javascript">class LinkNode &#123;
  constructor(val, next) &#123;
    this.val = val;
    this.next = next;
  &#125;
&#125;

/**
 * Initialize your data structure here.
 * 单链表 储存头尾节点 和 节点数量
 */
var MyLinkedList = function () &#123;
  this._size = 0;
  this._tail = null;
  this._head = null;
&#125;;

/**
 * Get the value of the index-th node in the linked list. If the index is invalid, return -1. 
 * @param &#123;number&#125; index
 * @return &#123;number&#125;
 */
MyLinkedList.prototype.getNode = function (index) &#123;
  if (index &lt; 0 || index &gt;= this._size) return null;
  // 创建虚拟头节点
  let cur = new LinkNode(0, this._head);
  // 0 -&gt; head
  while (index-- &gt;= 0) &#123;
    cur = cur.next;
  &#125;
  return cur;
&#125;;
MyLinkedList.prototype.get = function (index) &#123;
  if (index &lt; 0 || index &gt;= this._size) return -1;
  // 获取当前节点
  return this.getNode(index).val;
&#125;;

/**
 * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. 
 * @param &#123;number&#125; val
 * @return &#123;void&#125;
 */
MyLinkedList.prototype.addAtHead = function (val) &#123;
  const node = new LinkNode(val, this._head);
  this._head = node;
  this._size++;
  if (!this._tail) &#123;
    this._tail = node;
  &#125;
&#125;;

/**
 * Append a node of value val to the last element of the linked list. 
 * @param &#123;number&#125; val
 * @return &#123;void&#125;
 */
MyLinkedList.prototype.addAtTail = function (val) &#123;
  const node = new LinkNode(val, null);
  this._size++;
  if (this._tail) &#123;
    this._tail.next = node;
    this._tail = node;
    return;
  &#125;
  this._tail = node;
  this._head = node;
&#125;;

/**
 * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. 
 * @param &#123;number&#125; index 
 * @param &#123;number&#125; val
 * @return &#123;void&#125;
 */
MyLinkedList.prototype.addAtIndex = function (index, val) &#123;
  if (index &gt; this._size) return;
  if (index &lt;= 0) &#123;
    this.addAtHead(val);
    return;
  &#125;
  if (index === this._size) &#123;
    this.addAtTail(val);
    return;
  &#125;
  // 获取目标节点的上一个的节点
  const node = this.getNode(index - 1);
  node.next = new LinkNode(val, node.next);
  this._size++;
&#125;;

/**
 * Delete the index-th node in the linked list, if the index is valid. 
 * @param &#123;number&#125; index
 * @return &#123;void&#125;
 */
MyLinkedList.prototype.deleteAtIndex = function (index) &#123;
  if (index &lt; 0 || index &gt;= this._size) return;
  if (index === 0) &#123;
    this._head = this._head.next;
    // 如果删除的这个节点同时是尾节点，要处理尾节点
    if (index === this._size - 1) &#123;
      this._tail = this._head
    &#125;
    this._size--;
    return;
  &#125;
  // 获取目标节点的上一个的节点
  const node = this.getNode(index - 1);
  node.next = node.next.next;
  // 处理尾节点
  if (index === this._size - 1) &#123;
    this._tail = node;
  &#125;
  this._size--;
&#125;;

// MyLinkedList.prototype.out = function() &#123;
//     let cur = this._head;
//     const res = [];
//     while(cur) &#123;
//         res.push(cur.val);
//         cur = cur.next;
//     &#125;
// &#125;;
/**
 * Your MyLinkedList object will be instantiated and called as such:
 * var obj = new MyLinkedList()
 * var param_1 = obj.get(index)
 * obj.addAtHead(val)
 * obj.addAtTail(val)
 * obj.addAtIndex(index,val)
 * obj.deleteAtIndex(index)
 */
</code></pre>
<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><pre><code class="javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var reverseList = function (head) &#123;
  let cur = head;
  let prev = null;
  // 当cur为空时循环终止
  while (cur) &#123;
    // 每次tem都保存一下cur的下一个节点，因为后边要反转节点了
    let tem = cur.next;
    cur.next = prev;
    // 切换两个节点的值
    prev = cur;
    cur = tem;
  &#125;
  return prev;
&#125;;
</code></pre>
<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><pre><code class="javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var swapPairs = function (head) &#123;
  let temHead = new ListNode(0, head);
  // cur节点指向要交换的两个节点的前一个节点
  let cur = temHead;
  //  节点的下一个为空或者下一个的下一个为空结束（节点数量为奇数不用交换）
  while (cur.next &amp;&amp; cur.next.next) &#123;
    // 保存下一个节点以及下一次交换的节点
    const temNode = cur.next;
    const tem1Node = cur.next.next.next;
    // 交换节点
    cur.next = cur.next.next;
    cur.next.next = temNode;
    temNode.next = tem1Node;
    // 交换完之后cur往后移两位
    cur = cur.next.next;
  &#125;
  return temHead.next;
&#125;;
</code></pre>
<pre><code class="javascript">var swapPairs = function (head) &#123;
  // 定义虚拟节点，下一个指向头节点
  const headNode = new ListNode(0, head);
  // 定义指针节点，指针节点的后两个进行交换
  let curNode = headNode;
  // 当下一个节点或者下一个节点的下一个节点为空时结束循环(奇数个节点/偶数个节点)
  while (curNode.next &amp;&amp; curNode.next.next) &#123;
    // 保留下一个节点以及两个节点的下一个节点（反转后修改指向）
    const tem1 = curNode.next;
    const tem2 = curNode.next.next.next;//curNode节点是反转节点的前一个节点
    // 交换节点
    curNode.next = tem1.next;
    curNode.next.next = tem1;
    tem1.next = tem2;
    // 更换指针节点的值（指向反转节点的前一个节点）
    curNode = tem1;
  &#125;
  return headNode.next;
&#125;;
</code></pre>
<h3 id="删除链表倒数第N个节点"><a href="#删除链表倒数第N个节点" class="headerlink" title="删除链表倒数第N个节点"></a>删除链表倒数第N个节点</h3><pre><code class="javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @param &#123;number&#125; n
 * @return &#123;ListNode&#125;
 */
var removeNthFromEnd = function (head, n) &#123;
  // 倒数第n个节点表示正数size-n+1个节点
  let size = 0;
  let tem = head;
  while (tem) &#123;
    size++;
    tem = tem.next;
  &#125;
  let yn = true;
  let index = 1;
  tem = head;
  if (size == 1) &#123;
    return null;
  &#125;
  if (size == n) &#123;
    return head.next;
  &#125;
  while (yn) &#123;
    if (index == size - n) &#123;
      tem.next = tem.next.next;
      yn = false;
      return head;
    &#125;
    index++;
    tem = tem.next;
  &#125;
  return head;
&#125;;
</code></pre>
<p>双指针</p>
<pre><code class="javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @param &#123;number&#125; n
 * @return &#123;ListNode&#125;
 */
var removeNthFromEnd = function (head, n) &#123;
  let temHead = new ListNode(0, head)
  // 定义两个指针，快指针比慢指针多走n+1步，慢指针正好指向要删除节点的前一位
  let first = temHead;
  let second = temHead;
  let index = 1;//index从1开始
  while (first.next) &#123;
    if (index &gt;= n + 1) &#123;
      second = second.next;
    &#125;
    index++;
    first = first.next;
  &#125;
  second.next = second.next.next;
  return temHead.next;
&#125;;
</code></pre>
<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><pre><code class="javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val) &#123;
 *     this.val = val;
 *     this.next = null;
 * &#125;
 */

/**
 * @param &#123;ListNode&#125; head
 * @return &#123;boolean&#125;
 */
// 判断是否有环
var hasCycle = function (head) &#123;
  if (!head) &#123;
    return false;
  &#125;
  // 定义两个指针，一个快指针(每次循环走两步，慢指针每次走一步)
  let fastNode = head.next;
  let solwNode = head;
  while (fastNode &amp;&amp; solwNode &amp;&amp; fastNode.next) &#123;
    fastNode = fastNode.next.next;
    solwNode = solwNode.next;
    if (fastNode == solwNode) &#123;
      return true;
    &#125;
  &#125;
  return false;
&#125;;
</code></pre>
<p>找到环的入口</p>
<pre><code class="javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val) &#123;
 *     this.val = val;
 *     this.next = null;
 * &#125;
 */

/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
// 判断入口
var detectCycle = function (head) &#123;
  // 使用双指针(快指针，慢指针)判断是否有环
  let fastNode = head;
  let solwNode = head;
  while (true) &#123;
    // 如果快节点走到低了，表示没有环
    if (!fastNode || !fastNode.next) &#123;
      return null;
    &#125;
    fastNode = fastNode.next.next;
    solwNode = solwNode.next;
    // 相遇(有环)
    if (fastNode == solwNode) &#123;
      break;
    &#125;
  &#125;
  // 重置快节点，第一次相遇时正好是入口
  fastNode = head;
  while (fastNode != solwNode) &#123;
    fastNode = fastNode.next;
    solwNode = solwNode.next;
  &#125;
  return fastNode;
&#125;;
</code></pre>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>数组、set、map</p>
<h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><ol>
<li>用数组</li>
</ol>
<p>定义一个可以存放26个字母的数组，第一个字符串做加法，第二个字符串做减法，最后判断数组中元素是不是全部是0</p>
<ol start="2">
<li>字符串排序</li>
</ol>
<pre><code class="javascript">/**
 * @param &#123;string&#125; s
 * @param &#123;string&#125; t
 * @return &#123;boolean&#125;
 */
var isAnagram = function (s, t) &#123;
  if (s.length !== t.length || s === t) &#123;
    return false;
  &#125;
  const arrS = s.split(&#39;&#39;);
  const arrT = t.split(&#39;&#39;);
  arrS.sort();
  arrT.sort();
  for (let i = 0; i &lt; arrS.length; i++) &#123;
    if (arrS[i] !== arrT[i]) &#123;
      return false;
    &#125;
  &#125;
  return true;
&#125;;
</code></pre>
<h3 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h3><ol>
<li>哈希表(set)</li>
</ol>
<p>将第一个数组中的数据存放到哈希表中，遍历第二个数组然后出现过就加到结果数组中</p>
<ol start="2">
<li>set+排序</li>
</ol>
<pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums1
 * @param &#123;number[]&#125; nums2
 * @return &#123;number[]&#125;
 */
var intersection = function (nums1, nums2) &#123;
  nums1 = Array.from(new Set(nums1));
  nums2 = Array.from(new Set(nums2));
  const tem = [...nums1, ...nums2];
  tem.sort((a, b) =&gt; &#123;
    return a - b;
  &#125;)
  const res = []
  tem.forEach((elem) =&gt; &#123;
    if (tem.indexOf(elem) !== tem.lastIndexOf(elem) &amp;&amp; res.indexOf(elem) === -1) &#123;
      res.push(elem);
    &#125;
  &#125;)
  return res;
&#125;;
</code></pre>
<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number[]&#125;
 */
var twoSum = function (nums, target) &#123;
  let map = new Map();
  for (let i = 0, len = nums.length; i &lt; len; i++) &#123;
    if (map.has(target - nums[i])) &#123;
      return [map.get(target - nums[i]), i];
    &#125; else &#123;
      map.set(nums[i], i);
    &#125;
  &#125;
  return [];
&#125;;
</code></pre>
<h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><ol>
<li>暴力解法，四重for循环</li>
<li>遍历两个数组之和相加，存储到map中，另外需要存储出现的次数，再遍历另外两个数组，去map中查看是否有需要的元素</li>
</ol>
<pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums1
 * @param &#123;number[]&#125; nums2
 * @param &#123;number[]&#125; nums3
 * @param &#123;number[]&#125; nums4
 * @return &#123;number&#125;
 */
var fourSumCount = function (nums1, nums2, nums3, nums4) &#123;
  const map = new Map();
  // 遍历前两个数组将和存储到map中，并统计次数
  for (let i = 0; i &lt; nums1.length; i++) &#123;
    for (let j = 0; j &lt; nums2.length; j++) &#123;
      const sum = nums1[i] + nums2[j]
      map.set(sum, (map.get(sum) || 0) + 1)
    &#125;
  &#125;
  // 遍历剩余两个数组，判断map中是否具有目标元素(出现多少次就加多少个)
  let res = 0
  for (let i = 0; i &lt; nums3.length; i++) &#123;
    for (let j = 0; j &lt; nums4.length; j++) &#123;
      const sum = 0 - (nums3[i] + nums4[j]);
      res += map.get(sum) || 0
    &#125;
  &#125;
  return res
&#125;;
</code></pre>
<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>一个数组中找到三个元素，三个元素之和为0</p>
<ol>
<li>hash法做</li>
</ol>
<p>需要考虑去重，a、b、c都需要考虑去重</p>
<ol start="2">
<li>双指针</li>
</ol>
<p>对数组进行排序<br>a值固定，b和c用双指针去找，如果三个数的值相加大了，就移动右指针，如果小了就移动左指针</p>
<pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[][]&#125;
 */
var threeSum = function (nums) &#123;
  if (nums.length &lt; 3) &#123;
    return []
  &#125;
  // 数组排序
  nums.sort((a, b) =&gt; &#123;
    return a - b
  &#125;)
  // 目标结果是0，如果第一个元素都大于0，那么不可能获得结果
  if (nums[0] &gt; 0) &#123;
    return []
  &#125;
  const res = []
  for (let i = 0; i &lt; nums.length; i++) &#123;
    /* 
        判断第一个数是否重复,如果判断后一个的话判断的是数组中是否有重复元素，
        [-1,-1,2]
        所有判断前一个是否用过
    */
    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) &#123;
      continue;
    &#125;
    let left = i + 1
    let right = nums.length - 1
    while (right &gt; left) &#123;
      const sum = nums[i] + nums[right] + nums[left]
      if (sum &gt; 0) &#123;
        right--;
      &#125; else if (sum &lt; 0) &#123;
        left++;
      &#125; else if (sum == 0) &#123;
        res.push([nums[i], nums[left], nums[right]])
        /* 
          收获结果之后再进行去重操作
          去重,如果数组中元素是[0,-1,-1,-1,-1,1,1,1,1]
          left指针和right指针移动后指针指向的值是相同的，需要进行去重操作
        */
        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;
          left++
        &#125;
        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;
          right--
        &#125;
        // 去重完成之和继续循环
        left++
        right--
      &#125;
    &#125;
  &#125;
  return res
&#125;;
</code></pre>
<h3 id="四数之和-1"><a href="#四数之和-1" class="headerlink" title="四数之和"></a>四数之和</h3><pre><code class="javascript">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number[][]&#125;
 */
var fourSum = function (nums, target) &#123;
  if (nums.length &lt; 4) &#123;
    return []
  &#125;
  nums.sort((a, b) =&gt; &#123;
    return a - b
  &#125;)
  // 剪枝操作,这里需要加上target大于0
  if (nums[0] &gt; target &amp;&amp; target &gt; 0) &#123;
    return []
  &#125;
  /*
    双重for循环+定义两指针去寻找
    */
  const res = []
  for (let k = 0; k &lt; nums.length; k++) &#123;
    // 去重,判断是否与前一个数相等相等表示已经用过了
    if (k &gt; 0 &amp;&amp; nums[k] === nums[k - 1]) &#123;
      continue
    &#125;
    for (let i = k + 1; i &lt; nums.length; i++) &#123;
      // 去重,判断是否与前一个数相等相等表示已经用过了
      if (i &gt; k + 1 &amp;&amp; nums[i] === nums[i - 1]) continue;
      let left = i + 1;
      let right = nums.length - 1;
      while (right &gt; left) &#123;
        // 获得结果
        const sum = nums[k] + nums[i] + nums[left] + nums[right]
        if (sum &gt; target) &#123;
          right--
        &#125;
        if (sum &lt; target) &#123;
          left++
        &#125;
        if (sum === target) &#123;
          res.push([nums[k], nums[i], nums[left], nums[right]])
          // 去重
          while (right &gt; left &amp;&amp; nums[left] === nums[left + 1]) &#123;
            left++
          &#125;
          while (right &gt; left &amp;&amp; nums[right] === nums[right - 1]) &#123;
            right--
          &#125;
          left++
          right--
        &#125;
      &#125;
    &#125;
  &#125;
  return res
&#125;;
</code></pre>
<h2 id="周赛"><a href="#周赛" class="headerlink" title="周赛"></a>周赛</h2><ol start="8029">
<li>与车相交的点</li>
</ol>
<p>给你一个下标从 0 开始的二维整数数组 nums 表示汽车停放在数轴上的坐标。对于任意下标 i，nums[i] &#x3D; [starti, endi] ，其中 starti 是第 i 辆车的起点，endi 是第 i 辆车的终点。<br><strong>示例 1：</strong><br>输入：nums &#x3D; [[3,6],[1,5],[4,7]] 输出：7 解释：从 1 到 7 的所有点都至少与一辆车相交，因此答案为 7 。<br><strong>示例 2：</strong><br>输入：nums &#x3D; [[1,3],[5,8]] 输出：7 解释：1、2、3、5、6、7、8 共计 7 个点满足至少与一辆车相交，因此答案为 7 。</p>
<p>返回数轴上被车 任意部分 覆盖的整数点的数目。</p>
<pre><code class="javascript">/**
 * @param &#123;number[][]&#125; nums
 * @return &#123;number&#125;
 */
var numberOfPoints = function (nums) &#123;
  nums.sort((a, b) =&gt; &#123;
    return a[0] - b[0];
  &#125;);

  const set = new Set();
  // 将元素添加进set
  for (let i = 0; i &lt; nums.length; i++) &#123;
    for (let j = nums[i][0]; j &lt;= nums[i][1]; j++) &#123;
      set.add(j);
    &#125;
  &#125;
  return set.size;
&#125;;
</code></pre>
<p>以上就是这周的刷的算法，随后要及时复习，继续刷题，保持题感</p>
</div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">夜星</div><div class="author-info__description">前端切图仔</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XY0987"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/mjh1667002013" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1976083684@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/23/webFontBasic/" title="前端基础">前端基础</a><time datetime="2023-11-22T16:00:00.000Z" title="发表于 2023-11-23 00:00:00">2023-11-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/16/tools/" title="工具">工具</a><time datetime="2023-09-15T16:00:00.000Z" title="发表于 2023-09-16 00:00:00">2023-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/10/algorithm/" title="算法">算法</a><time datetime="2023-09-09T16:00:00.000Z" title="发表于 2023-09-10 00:00:00">2023-09-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/29/index/" title="小站说明">小站说明</a><time datetime="2023-07-28T16:00:00.000Z" title="发表于 2023-07-29 00:00:00">2023-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/29/project/" title="项目">项目</a><time datetime="2023-07-28T16:00:00.000Z" title="发表于 2023-07-29 00:00:00">2023-07-29</time></div></div></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><span class="card-archive-list-count">3</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">6</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">1.3k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-11-27T08:44:41.288Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/top_bac.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 夜星</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>